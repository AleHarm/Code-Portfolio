# Start Here

`Name`: Alex Harmon  
`NetID`: ah962

For each problem below, you will,

1. Fill in the the flag
2. List the steps necessary to exploit the binary. *(May be a single line.)*
3. Provide a patch that fixes the exploit. *(Generated using `make diff`.)*
4. An explanation of what the vulnerability was and how the patch fixes it. *(Keep this explanation short and to the point.)*

---

## problem1

### Flag
flag{366-iNt3G3r5iGNc0nV3r5i0N}

### Exploit Steps
1. Input a bunch of random numbers with nothing working
2. Thought there was a sign checking step
3. Finally used a large negative number
4. It worked

### Patch
```diff
--- .originals/problem1.c	2024-09-18 19:42:54.000000000 +0000
+++ problem1.c	2024-10-02 17:29:04.992574400 +0000
@@ -32,7 +32,7 @@
 
 // Check to make sure the user has enough money to process the withdrawal
 int check_withdraw_amount(int amount, struct user_account *u) {
-  return amount < get_account_balance(u);
+  return amount < get_account_balance(u) && 0 <= amount;
 }
 
 // Handle a large withdraw
```

### Explanation
Currently, the program does not check for sign. Before it withdraws, it just checks that the withdrawl amount is less than the amount in the account. So by entering a negative number, you can subtract a negative to add funds to your account. 
To fix this, simply add a step to check if the number entered is negative, and do not allow negative inputs

---

## problem2

### Flag
flag{366-bUFF3r0v3RF10w_r3turn}

### Exploit Steps
1. Set a breakpoint for backdoor in gdb to get function address
2. Write address to file along with 32 As to fill the buffer
3. Continue adding As until backdoor was run (because it overflowed onto the return address)

### Patch
```diff
--- .originals/problem2.c	2024-09-18 19:42:54.000000000 +0000
+++ problem2.c	2024-09-26 14:12:03.098860900 +0000
@@ -10,7 +10,7 @@
   char out[32];
 
   memset(out, 0, sizeof(out));
-  strcpy(out, input);
+  strncpy(out, input, sizeof(out) - 1);
 
   // Copy the user's input and print it out.
   printf("user:   %s\n", input);

```

### Explanation
strcpy does not specify the number of bytes it takes in. This makes it easy to input more characters than the buffer size, and overwrite return addresses. However, strncpy (notice the n) requires you to specify the number of bytes to read in. 

We can then use the size of the variable you're reading the input into as the size of the input to accept (-1 for the terminating character). 

This ensures there will be no buffer overflow

---

## problem3

### Flag
flag{366-BufFeR0v3rf10W_C4n4ry}

### Exploit Steps
1. Identify how large the buffer is
2. Identify where password was stored
3. Figure out what "shifted by 1" means
4. Input BUFFER_SIZE characters, and the PASSWORD_SIZE characters of an ASCII character that is 1 greater than the characters placed in the BUFFER_SIZE section
5. Run it

### Patch
```diff
--- .originals/problem3.c	2024-09-18 19:42:54.000000000 +0000
+++ problem3.c	2024-10-01 16:43:53.344002300 +0000
@@ -16,7 +16,8 @@
 
   // Check that the passwords match. We're using my super special comparison function that
   // shifts password characters over by 1... throws off the hackers!
-  strcpy(passwordBuffer, input);
+  memset(passwordBuffer, 0, sizeof(passwordBuffer));
+  strncpy(passwordBuffer, input, sizeof(passwordBuffer) - 1);
 
   for (size_t i = 0; i < sizeof(passwordBuffer); i++) {
     passwordBuffer[i]++;
```

### Explanation
This code is vulnerable because an attacker can overlfow the passwordbuffer onto the password stored in memory. This allows them to input whatever password they'd like and (provided they know the method of storage andd checking), can have the overflowed value match the inputs value.

To fix this, I added a terminating character at the end of the buffer, and only allow the user to input characters up to the size of the buffer

---

## problem4

### Flag
flag{366-iNt3g3r0v3rF10w}

### Exploit Steps
1. Find out what data type the value and multiple values are stored in
2. Figure out how large that data type is
3. Enter a number large enough to overflow to -1
4. use that as a way to multiply two "positives" to match the negative key value

### Patch
```diff
--- .originals/problem4.c	2024-09-18 19:42:54.000000000 +0000
+++ problem4.c	2024-10-01 17:04:53.803553900 +0000
@@ -8,7 +8,7 @@
 static const int reset_key = -504;
 
 int main() {
-  int value, factor, result, password;
+  unsigned int value, factor, result, password;
 
   // This is a simple calculator with some input checking
   printf("Enter a value: ");
```

### Explanation
This code was unsafe because the int was a signed int. Because of this, a large enough positive value could wrap around a return a negative value when accessed, allowing the usr to multiply two "positive" numbers to get a negative.

This can be solved by simply using an unsigned int instead of a signed int. This prevents reading the value as a negative number

---

## problem5

### Flag
flag{366-r5C3c0nd170n}

### Exploit Steps
1. Start the program in the background
2. Create the file it's going to try to access
3. When the program tries to access the file, I have access because I was the creator of the file

### Patch
```diff
--- .originals/problem5.c	2024-09-18 19:42:54.000000000 +0000
+++ problem5.c	2024-10-01 17:57:16.874996300 +0000
@@ -15,7 +15,7 @@
     printf("Hey, you shouldn't have access to my file... What are you trying to pull? Go away!\n");
   } else {
     // I'm tired. Checking access is hard work... I need some sleep. 0.1 seconds should do it.
-    usleep(100000);
+    // usleep(100000);
 
     // Ok, let's open this file and write the flag to it.
     // Haha... just kidding, the user doesn't have access to the file, so this call will fail.

```

### Explanation
This program is vulnerable because it checks to see if the file is already created, then waits before it checks it again. During that period of waiting, the file can be accessed and all sorts of nefarious things can be done. By removing the wait period, the program is much more secure.

---

## problem6

### Flag
flag{366-1n73g3RUnd3rfl0W}

### Exploit Steps
1. Found the size of the buffer my input went into
2. Saw the number of guesses was stored directly afterwards
3. Knew that if I could increase my number of guesses I could guess all combinations of 3 lowercase letters
4. Had ChatGPT generate a text file with all possible 3 letter combinations (17,000)
5. Overwrote the number of guesses with 99,999
6. Input every combination until one of them worked

### Patch
```diff
--- .originals/problem6.c	2024-09-18 19:42:54.000000000 +0000
+++ problem6.c	2024-10-02 00:02:38.541739600 +0000
@@ -12,8 +12,9 @@
   char password[4];
   memset(password, (char)0, sizeof(password));
 
-  char input[4];
   unsigned int remainingGuesses;
+  char input[4];
+
 
   // Generate a random string of 3 lowercase letters
   srand((unsigned int)time(NULL));
@@ -29,9 +30,10 @@
 
   do {
     printf("Guess: ");
-    if (scanf("%3s", input) != 1) {
+    if (fgets(input, sizeof(input) - 1, stdin) == NULL) {
       break;
     }
+    input[strcspn(input, "\n")] = 0;
 
     if (remainingGuesses > 0) {
       if (strncmp(password, input, sizeof(password)) == 0) {

```

### Explanation
The code was vulnerable because the input could overwrite onto the remaining guesses variable. To fix this, simply switch the position they're declared at. Additionally, you can use fgets instead of scanf to specify the number of characters read in

---

## problem7

### Flag
flag{366-Rac3c0ndi7i0N_2}

### Exploit Steps
1. Find the max size of a short in C
2. make several deposits in that amount to fill up account
3. make A LOT of withdrawls, including some above the short limit
4. Win

### Patch
```diff
--- .originals/problem7.c	2024-09-18 19:42:54.000000000 +0000
+++ problem7.c	2024-10-02 13:38:07.338132400 +0000
@@ -23,12 +23,8 @@
     return NULL;
   }
 
-  // Subtraction seems dangerous... I'll implement my own awesome subtraction
-  // method that must be safe!
   printf("Connecting to server to process withdrawal of $%hu...\n", amount);
-  for (unsigned short i = 0; i < amount; i++) {
-    --accountBalance;
-  }
+  accountBalance -= amount;
   return NULL;
 }
 
@@ -42,12 +38,8 @@
     return NULL;
   }
 
-  // Addition also seems dangerous... I'll implement my own awesome addition
-  // method that must be safe!
   printf("Connecting to server to process deposit of $%hu\n", amount);
-  for (unsigned short i = 0; i < amount; i++) {
-    ++accountBalance;
-  }
+  accountBalance += amount;
   return NULL;
 }
 

```

### Explanation
This exploit works because the deposits and withdrawls are done incrementally rather than all at once. This can cause the different threads to build on the work of one another and subtract more than is available in the account. 

To fix this, I made it so that the program will subtract and add the total transaction amount rather than 1 digit at a time.. This will prevent other threads from building on small mistakes and remove race conditions.

---
